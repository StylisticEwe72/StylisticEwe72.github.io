<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>題庫練習網站</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            text-align: center;
            margin-top: 50px;
        }
        .question-container {
            margin-bottom: 20px;
        }
        .options-container {
            display: flex;
            flex-direction: column;
            align-items: center;
        }
        .options-container button {
            margin: 5px;
            padding: 10px;
            cursor: pointer;
            width: 80%; /* 控制按鈕寬度，保持美觀 */
        }
        .correct {
            background-color: green;
            color: white;
        }
        .incorrect {
            background-color: red;
            color: white;
        }
    </style>
</head>
<body>

    <div class="question-container">
        <h2 id="question">這裡是題目</h2>
    </div>
    <div class="options-container">
        <button class="option" onclick="checkAnswer(this)">選項 1</button>
        <button class="option" onclick="checkAnswer(this)">選項 2</button>
        <button class="option" onclick="checkAnswer(this)">選項 3</button>
        <button class="option" onclick="checkAnswer(this)">選項 4</button>
    </div>
    <div id="feedback" style="margin-top: 20px;"></div>

    <script>
        const questions = [
            {
                question: "一般說來,執行緒在執行的時候所需的資源將會比行程來的",
                options: ["小", "一樣", "大", "無法確定,要視情況"],
                correct: "小"
            },
            {
                question: "一般說來,行程可以透過下列何者來與本地端作業系統溝通",
                options: ["系統呼叫", "聲音", "傳聲筒", "變數傳遞"],
                correct: "系統呼叫"
            },
            {
                question: "一般在UNIX 系統上可見到的 pthread(POSIX thread),是遵循下列何種標準",
                options: ["POSIX 1003.1c", "POSIX 1003.5", "POSIX 2003", "POSIX 801.C"],
                correct: "POSIX 1003.1c"
            },
            {
                question: "一般說來,行程在做本文切換的時候,會比執行緒作本文切換時來的慢,其主要原因是",
                options: ["行程在做本文切換的時候需要轉換整個虛擬記憶體位址", "行程需要釋放CPU的使用權", "行程需要獲得CPU的使用權", "行程要傳遞資訊給CPU"],
                correct: "行程在做本文切換的時候需要轉換整個虛擬記憶體位址"
            },
            {
                question: "一般說來,我們如何計算一個行程的下一個CPU使用時間",
                options: ["算術平均數", "指數平均數", "加權平均數", "統計平均數"],
                correct: "指數平均數"
            },
            {
                question: "長期、中期、短期排班程式中,何者的執行頻率最高",
                options: ["長期排班程式", "中期排班程式", "短期排班程式", "多層佇列排程"],
                correct: "短期排班程式"
            },
            {
                question: "下列哪種排班演算法較適合使用在分時系統中",
                options: ["FCFS", "SJF", "RR", "SRT"],
                correct: "RR"
            },
            {
                question: "下列哪種排班演算法不會產生某行程飢餓(Starvation)的狀況?",
                options: ["優先權", "SJF", "RR", "SRT"],
                correct: "RR"
            },
            {
                question: "干特圖是由誰所發明的",
                options: ["美國科學家干特", "中研院院長李遠哲", "美國汽車大王福特", "愛因斯坦"],
                correct: "美國科學家干特"
            },
            {
                question: "定量模式分析的缺點是常有偏頗的情形,但其優點是",
                options: ["簡單", "複雜", "步驟繁雜", "資料量龐大"],
                correct: "簡單"
            },
            {
                question: "下列何者不是被拿來當CPU排班的準則?",
                options: ["行程所需時間", "回應時間", "I/O 等待時間", "CPU使用率"],
                correct: "I/O 等待時間"
            },
            {
                question: "對分時系統而言那一項排班準則最重要?",
                options: ["等待時間", "回應時間", "整體成效", "CPU 使用率"],
                correct: "回應時間"
            },
            {
                question: "以下何者不是呼叫 fork()的缺點",
                options: ["需要做大量記憶體的複製", "進行內文切換時需付出相當的代價", "兩個行程間可快速交換資料", "兩個行程間 無法直接進行溝通"],
                correct: "兩個行程間可快速交換資料"
            },
            {
                question: "以下何者不為多執行緒程式的優點",
                options: ["在一個程式某一部份被暫停,或程式在執行冗長操作時,便無法繼續執行", "執行緒問將共用它們所屬行程的記憶體和資源", "節省記憶體空間及快速的內文切換", "每一執行緒可以並行地在不同的處理器上執行"],
                correct: "在一個程式某一部份被暫停,或程式在執行冗長操作時,便無法繼續執行"
            },
            {
                question: "以下何者不為多核心系統編寫程式中目前的挑戰的領域",
                options: ["切割活動", "平衡", "資料分裂", "資料獨立性"],
                correct: "資料獨立性"
            },
            {
                question: "以下對執行緒的描述,何者正確?",
                options: ["重量級行程", "使用CPU資源的基本單元", "與其他的執行緒分別使用獨立位址空間", "包含了一個程式計數器、一組暫存器、一個堆疊空間和所有執行時所用到的資料與程式碼"],
                correct: "使用CPU資源的基本單元"
            },
            {
                question: "以下對使用者執行緒及核心執行緒的描述,何者錯誤",
                options: ["使用者執行緒利用執行緒函式庫來提供", "核心執行緒建立與管理執行緒時比使用者執行緒來得慢", "使用者執行緒建立與管理執行緒時比較有效率", "兩種執行緒,都是當行程中的執行緒暫停,則同行程中其他所有執行緒也都會暫停執行"],
                correct: "兩種執行緒,都是當行程中的執行緒暫停,則同行程中其他所有執行緒也都會暫停執行"
            },
            {
                question: "以下何種多執行緒的模型,會消耗比較多的資源",
                options: ["多對一", "一對多", "一對一", "多對多"],
                correct: "一對一"
            },
            {
                question: "多元程式規劃系統的主要目的是",
                options: ["禁止行程使用CPU,藉以降低CPU使用率", "隨時保有一個行程在執行,藉以提高CPU使用率", "只讓特定的行程使用CPU,盡量減少CPU使用率", "亂數選取行程執行,CPU使用率亦難以估計"],
                correct: "隨時保有一個行程在執行,藉以提高CPU使用率"
            },
            {
                question: "在單一行程或批次的系統中,當行程在等待時CPU是",
                options: ["忙碌狀態", "等待狀態", "休眠狀態", "閒置狀態"],
                correct: "閒置狀態"
            },
            {
                question: "行程排程是",
                options: ["多工系統", "批次系統", "即時系統", "嵌入式系統的基礎"],
                correct: "多工系統"
            },
            {
                question: "CPU 排班程式(短程排程器)的用途是",
                options: ["將閒置已久的程式置換出去,以降低多工程度", "從就緒佇列之中選出其中一個行程來執行", "從就緒佇列之中選出其中一個行程來刪除", "將閒置已久的程式置換回來,以增加多工程度"],
                correct: "從就緒佇列之中選出其中一個行程來執行"
            },
            {
                question: "以下哪兩種行程狀態的變化,為行程主動放棄執行權",
                options: [
                 "執行狀態->等待狀態、執行狀態->就緒狀態",
                 "執行狀態->等待狀態、執行狀態->結束狀態", 
                 "執行狀態->就緒狀態、等待狀態->就緒狀態", 
                 "執行狀態->結束狀態、執行狀態->就緒狀態"
                ],
                correct: "執行狀態->等待狀態、執行狀態->結束狀態"
            },
            {
                question: "以下對不可搶先式排程的描述,何者錯誤",
                options: [
                 "只有當執行中的行程進入懸置狀態或是終止的時候,其他行程才有可能取得CPU的控制權",
                 "在現代的互動式系統中,這樣的做法可能會讓其他的使用者或應用程式等待過久", 
                 "可以讓執行中的行程完成整個CPU暴衝", 
                 "需要比較複雜的CPU設計"
                ],
                correct: "需要比較複雜的CPU設計"
            },
            {
                question: "以下為可搶先排班中,CPU排班的決策發生在下面四種情況,請問以下哪種狀況為錯誤?",
                options: [
                 "當一行程從執行狀態轉變成等待狀態時(例如,I/O要 求,祈求等待其中一個子行程的結束)",
                 "當一行程從執行狀態轉變成就緒狀 態時(例如,當有中斷發生時)", 
                 "當一行程閒置時", 
                 "當一行程終止時"
                ],
                correct: "當一行程閒置時"
            },
            {
                question: "以下何者不適合當作CPU排班評定的標準",
                options: [
                 "產量",
                 "CPU閒置率", 
                 "回復時間", 
                 "等待時間"
                ],
                correct: "CPU閒置率"
            },
            {
                question: "以下何者為最簡單的不可搶先排程法",
                options: [
                 "FCFS",
                 "SJF", 
                 "SRTF", 
                 "RR"
                ],
                correct: "FCFS"
            },
            {
                question: "請問FCFS會產生什麼問題",
                options: [
                 "可預測性高",
                 "複雜", 
                 "護航現象", 
                 "等待時間變動很大"
                ],
                correct: "護航現象"
            },
            {
                question: "以下何者為最佳的不可搶先排程法",
                options: [
                 "FCFS",
                 "SJF", 
                 "SRTF", 
                 "RR"
                ],
                correct: "SJF"
            },
            {
                question: "以下何者不為優先權的指定標準",
                options: [
                 "指定的某些參數",
                 "使用者等級", 
                 "行程的特性", 
                 "行程的名字"
                ],
                correct: "行程的名字"
            },
            {
                question: "循環分時排程(Round-Robin Scheduling)類似什麼的小單位搶先版",
                options: [
                 "FCFS",
                 "SJF", 
                 "SRTF", 
                 "RR"
                ],
                correct: "FCFS"
            },
            {
                question: "循環分時排程(Round-Robin Scheduling)能提供較佳的",
                options: [
                 "等待時間",
                 "反應時間", 
                 "回覆時間", 
                 "休眠時間"
                ],
                correct: "反應時間"
            },
            {
                question: "以下對於多層佇列排程的描述,何者正確?",
                options: [
                 "佇列與佇列之間沒有優先權的關係",
                 "將行程分類,不同類型的行程分在同一佇列", 
                 "不會產生飢餓的 現象", 
                 "相同類型的行程分在同一佇列,在每個佇列內使用最適合該類行程的排程方法"
                ],
                correct: "相同類型的行程分在同一佇列,在每個佇列內使用最適合該類行程的排程方法"
            },
            {
                question: "以下對於多處理器排程的描述,何者錯誤?",
                options: [
                 "若系統中的處理器皆為相同架構時,此系統稱為同質",
                 "同質系統中,通常將所有就緒的行程都放置於同一個佇列中", 
                 "若系統中的處理器皆為相同架構時,此系統稱為異質", 
                 "對稱式多元處理由各處理器自行進行排程"
                ],
                correct: "若系統中的處理器皆為相同架構時,此系統稱為異質"
            },
            {
                question: "以下對於即時排程的敘述,何者錯誤",
                options: [
                 "分派延遲必須很短",
                 "系統呼叫必須是不可搶先的", 
                 "系統呼叫中加入可搶先點", 
                 "整個核心中的資料結構 都需要使用同步的機制來保護"
                ],
                correct: "系統呼叫必須是不可搶先的"
            },
            {
                question: "Which of the following descriptions regarding the multithread models: In (??) model, only one thread can access the kernel at a time on multiprocessors.",
                options: [
                 "Many-to-One",
                 "One-to-One", 
                 "Many-to-Many", 
                 "One-to-Many"
                ],
                correct: "One-to-One"
            },
            {
                question: "Which of the following descriptions regarding the multithread models: In (??) model, it cannot support parallel execution.",
                options: [
                 "Many-to-One",
                 "One-to-One", 
                 "Many-to-Many", 
                 "One-to-Many"
                ],
                correct: "Many-to-One"
            },
            {
                question: "Which of the following descriptions regarding the multithread models: In (??) model, the entire process will not affect if a thread makes a blocking system call.",
                options: [
                 "Many-to-One",
                 "One-to-One", 
                 "Many-to-Many", 
                 "One-to-Many"
                ],
                correct: "One-to-One"
            },
            {
                question: "Which of the following descriptions regarding the multithread models: In (??) model, the number of kernel threads can be specific to either a particular application or a particular machine",
                options: [
                 "Many-to-One",
                 "One-to-One", 
                 "Many-to-Many", 
                 "One-to-Many"
                ],
                correct: "Many-to-Many"
            },
            {
                question: "Which of the following descriptions regarding the multithread models: In (??) model, the entire process will block if a thread makes a blocking system call.",
                options: [
                 "Many-to-One",
                 "One-to-One", 
                 "Many-to-Many", 
                 "One-to-Many"
                ],
                correct: "Many-to-One"
            },
            {
                question: "Which of the following descriptions regarding the multithread models: In (??) model, developers can create as many user threads as necessary. ",
                options: [
                 "Many-to-One",
                 "One-to-One", 
                 "Many-to-Many", 
                 "One-to-Many"
                ],
                correct: "Many-to-Many"
            },
            {
                question: "Which of the following descriptions regarding the multithread models: The two-level model is a variation of the (??) model. ",
                options: [
                 "Many-to-One",
                 "One-to-One", 
                 "Many-to-Many", 
                 "One-to-Many"
                ],
                correct: "Many-to-Many"
            },
            {
                question: "Multi-Level-Feedback-Queue(MLFQ) is an approximation to (??) scheduling",
                options: [
                 "FCFS",
                 "SRTF", 
                 "SJF", 
                 "RR"
                ],
                correct: "FCFS"
            },
            {
                question: "(??) scheduling algorithm always favors short processes",
                options: [
                 "FCFS",
                 "SRTF", 
                 "SJF", 
                 "RR"
                ],
                correct: "SJF"
            },
            {
                question: "scheduling algorithm would probably have convey effect",
                options: [
                 "FCFS",
                 "SRTF", 
                 "SJF", 
                 "RR"
                ],
                correct: "FCFS"
            },
            {
                question: "(??) scheduling algorithm is non-preemptive",
                options: [
                 "FCFS",
                 "SRTF", 
                 "SJF", 
                 "RR"
                ],
                correct: "FCFS"
            },
            {
                question: "(??) scheduling algorithm is a variation of the priority scheduling algorithm.",
                options: [
                 "FCFS",
                 "SRTF", 
                 "SJF", 
                 "RR"
                ],
                correct: "SRTF"
            },
            {
                question: "(??) scheduling algorithm depends on the length of the next CPU burst of a process, rather than its total length",
                options: [
                 "FCFS",
                 "SRTF", 
                 "SJF", 
                 "RR"
                ],
                correct: "SRTF"
            },
            {
                question: "If the time quantum is to large, round-robin scheduling degenerates to (??) scheduling",
                options: [
                 "FCFS",
                 "SRTF", 
                 "SJF", 
                 "RR"
                ],
                correct: "FCFS"
            },
            {
                question: "On SMP systems, it is important to keep the workload balanced among all processors. There are two general approaches to load balancing. (??) migration occurs when an idle processor gets a waiting task from a busy processor.",
                options: [
                 "push",
                 "pull", 
                 "load", 
                 "balance"
                ],
                correct: "pull"
            },
            {
                question: "On SMP systems, it is important to keep the workload balanced among all processors. There are two general approaches to load balancing. (??) migration checks the load of each processor periodically, if there is not balanced, the system migrate the processes from an overloading processor to an idle processor.",
                options: [
                 "push",
                 "pull", 
                 "load", 
                 "balance"
                ],
                correct: "push"
            },
            {
                question: "Semaphore 是在處理什麼問題?",
                options: [
                 "死結",
                 "虛擬記憶體", 
                 "CPU排班", 
                 "臨界區間(同步)"
                ],
                correct: "臨界區間(同步)"
            },
            {
                question: "當一個行程會與其他行程共享資訊,或是影響其他行程所執行之指令的行程,就稱為",
                options: [
                 "cofunction process",
                 "cooperating process", 
                 "sharing process", 
                 "independent process"
                ],
                correct: "cooperating process"
            },
            {
                question: "行程合作過程中所牽涉到的協調問題與處理機制稱為",
                options: [
                 "臨界區",
                 "關鍵區", 
                 "同步", 
                 "死結"
                ],
                correct: "同步"
            },
            {
                question: "行程間的通訊稱謂",
                options: [
                 "OPC",
                 "ICP", 
                 "PAC", 
                 "IPC"
                ],
                correct: "IPC"
            },
            {
                question: "下列何者不是行程間常用的共享資訊的方式",
                options: [
                 "匯流排通訊",
                 "共用的檔案", 
                 "共享記憶體", 
                 "信號"
                ],
                correct: "信號"
            },
            {
                question: "下列哪一個典型的同步問題在課本中沒有提到",
                options: [
                 "記憶體讀寫問題",
                 "有限緩衝區問題", 
                 "哲學家進餐的問題", 
                 "讀取者-寫入者問題"
                ],
                correct: "記憶體讀寫問題"
            },
            {
                question: "下列何者不是合作行程問可能發生的問題",
                options: [
                 "starvation",
                 "consistency", 
                 "deadlock", 
                 "race condition"
                ],
                correct: "consistency"
            }
        ];

        let currentQuestionIndex;

        function shuffleArray(array) {
            for (let i = array.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [array[i], array[j]] = [array[j], array[i]];
            }
        }

        function loadQuestion() {
            currentQuestionIndex = Math.floor(Math.random() * questions.length);
            const currentQuestion = questions[currentQuestionIndex];
            document.getElementById('question').textContent = currentQuestion.question;

            const optionsButtons = document.querySelectorAll('.option');
            shuffleArray(currentQuestion.options);

            optionsButtons.forEach((button, index) => {
                button.textContent = currentQuestion.options[index];
                button.classList.remove('correct', 'incorrect');
            });

            document.getElementById('feedback').textContent = '';
        }

        function checkAnswer(selectedButton) {
            const currentQuestion = questions[currentQuestionIndex];
            const selectedAnswer = selectedButton.textContent.trim();

            if (selectedAnswer === currentQuestion.correct) {
    document.getElementById('feedback').textContent = '正確!';
    selectedButton.classList.add('correct');
} else {
    document.getElementById('feedback').innerHTML = '錯誤! 正確答案是:<br>' + currentQuestion.correct;
    selectedButton.classList.add('incorrect');
}


            setTimeout(() => {
                loadQuestion();
            }, 2000); // 延遲1.5秒進入下一題
        }

        // 初始載入第一題
        loadQuestion();
    </script>

</body>
</html>
